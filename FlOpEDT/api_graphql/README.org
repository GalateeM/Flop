#+title: README GraphQL ; pour les L3
#+options: author:nil

Un =README= sur la mise en place de l'API sous GraphQL.

Actuellement sur la branche =graphql= du git général.

* Configuration
- On utilise le module python [[https://docs.graphene-python.org/projects/django/en/latest/][graphene-django]] dans =Django=.
** TODO Installer les nouveaux modules python
Activer son environnement virtuel, et
  #+begin_src shell
    cd FlOpEDT
    pip install -r ../requirements.txt
  #+end_src
** TODO Modifier les droits en base
Autoriser l'utilisateur =flop_user= à créer une base de données. Pendant la
phase de tests, =pytest= va en effet utiliser ce =user= pour créer une base de
données :
  #+begin_src sql
    ALTER USER flop_user CREATEDB ;
  #+end_src

* Requêtes interactives
- =graphiql= est disponible à =localhost:8000/graphql=
- Possibilité de faire des requêtes interactives pour tester ou découvrir
- Il y a de l'autocomplétion, c'est pratique

* Tests
- On utilise [[https://realpython.com/pytest-python-testing/][pytest]]
- Pour l'instant, il reste des tests obsolètes, donc le lancer avec
  #+begin_src shell
    pytest api_graphql
  #+end_src
- Cette exécution-ci ne doit conduire à aucune erreur. Lors de la phase d'ajout
  de tests, une autre exécution conduira sûrement à une erreur.
- Quand il n'y a pas de modification de la structure de la base de données (en
  gros, pas de changement dans le =models.py= des applications), on peut utiliser
  #+begin_src shell
    pytest api_graphql --reuse-db
  #+end_src
  pour [[https://pytest-django.readthedocs.io/en/latest/database.html#reuse-db-reuse-the-testing-database-between-test-runs][accélérer l'exécution du test]]

* Nodes (/Serializers)
- Un exemple dans =dummy/types.py=
- Une classe qui implémente l'interface =relay.Node=, un autre non.
- Sans =relay.Node=, la =Query= peut avoir un champ de type liste avec =List=
- Avec =relay.Node=, la =Query= peut avoir un champ de type liste avec =DjangoFilterConnectionField=
- Avec =relay.Node=, on peut faire des filtres plus facilement (/cf./ le champ
  =filter_fields= de la classe =Meta= de =DepartmentNode= -- dans
  =api_graphql/dummy/types.py=). Pour un exemple de requête, voir
  =api_graphql/dummy/test=

* Resolvers
- Un exemple dans =dummy/resolvers.py=
- Pour résoudre des champs (calculer leurs valeurs)

* Query
- Un exemple dans =dummy.query.py=
- La =Query= qui servira ce sous-répertoire.

* Organisation
- Sous le répertoire =api_graphql=, on split en sous-répertoires, dont la
  structure peut ressembler à =dummy=.
  - Un fichier =types.py= pour définir les types de données manipulées
    (qui font le lien entre les objets en base (ou plutôt des objets vus via
    l'ORM (Object Relational Mapping)) et la machine cliente)
  - Un fichier =query.py= pour définir la requête principale du sous-répertoire
    considéré.
  - Un fichier =resolvers.py= pour définir la manière dont les champs de la
    requête seront remplis.
- *@L3 MIASHS :* Pour l'organisation du travail, une proposition :
  - composition de binômes
    - un rôle de conception de tests
    - un rôle de conception des requêtes
  - au sein d'un binôme, échange des rôles tous les jours ou tous les deux jours
  - commencer la journée par se mettre d'accord sur
    - quelles requêtes seront traitées dans la journée
    - une spécification précise des requêtes
  - lorsque les deux personnes ont fini une requête donnée, tester et corriger
- *@Léo :* proposition
  - peut-être écrire quelque part (éventuellement dans ce fichier) une
    liste de toutes les classes qui sont dans les =models.py=, et indiquer en
    face de chaque item par où on peut y accéder, où rien si pas encore
    accessible.
  - si classes très similaires, possibilité de faire la première pour donner un
    exemple, et de laisser les autres pour les MIASHS

* Remarques
- Attention, les erreurs ne sont pas toujours très explicites. Plutôt que de
  laisser tourner le =runserver=, vous pouvez lancer un shell django
  #+begin_src python
    ./manage.py shell
  #+end_src
  et faire des import à la main pour voir si rien d'évident n'est à corriger
  #+begin_src python
    from api_graphql.dummy import types, query, resolvers
  #+end_src
- A priori, utiliser =fields = '__all__'= est déconseillé.


* TODO Après la première phase [0/7]
- [ ] =BreakingNews=
  - [ ] Rendre cohérente la gestion des semaines avec le reste du projet
    - [ ] Modifier =displayweb.models.py= (s'inspirer de =ScheduledCourse dans
      =base.models.py=, par exemple)
    - [ ] Modifier =api_graphql/bknews/types.py= en conséquence
    - [ ] Il manque des champs utiles
- [ ] Rassembler la construction des fixtures communes dans un ou des fichiers,
  dans le•s•quel•s• tous les tests pourront piocher.
- [ ] Nettoyer les imports et l'organisation : par exemple, =client_query= n'a
  pas grand chose à faire dans le test pour les modules. Il devrait être dans un
  truc commun.
- [ ] Virer les =fields = '__all__'=
- [ ] Tests pour =department=
- [ ] Si on continue à utiliser l'idée de =api_graphql/lib.py=, il faudrait que
  l'histoire des =edges= et =node= soit plus explicite dans les noms. Là, on a
  l'impression qu'une =query= récupère forcément un élément =edges= (via
  =execute_query=). Mais cela ne vaut que pour des =DjangoConnectionField=.
- [ ] Plus globalement, il y a une réflexion à avoir sur la manière dont on
  nomme les requêtes. Dans la précédente =API= (dans le répertoire =api=), grâce
  aux routeurs et aux URLs, on avait un moyen assez propre de gérer les
  namespaces. Avec le système semi-artisanal de =api_graphql/auto.py=,
  =api_graphql/base.py= et =api_graphql/schema.py=, on a perdu ça. Il faut sans
  doute réfléchir à un système avec des préfixes pour éviter les conflits entre
  toutes les requêtes qu'on va ramener dans la requête principale.

* TODO Dans un second temps [0/2]
- [ ] Gestion des droits
- [ ] Optimisation des requêtes
